!----------------------------------------------------------------------------
!   Copyright 2016 Florian Schumacher (Ruhr-Universitaet Bochum, Germany)
!
!   This file is part of ASKI version 1.1.
!
!   ASKI version 1.1 is free software: you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation, either version 2 of the License, or
!   (at your option) any later version.
!
!   ASKI version 1.1 is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   You should have received a copy of the GNU General Public License
!   along with ASKI version 1.1.  If not, see <http://www.gnu.org/licenses/>.
!----------------------------------------------------------------------------
!> \brief inversion grid consisting SPECFEM3D elements as inversion grid cells
!!
!! \details Use the specfem3d for ASKI main file generated by specfem3d-for-ASKI using ASKI_type_inversion_grid = 4,
!!   which contains wavefield points for complete elements (all GLL points, in fact)
!!   and they are stored in order as handled in specfem. Furthermore their values of jacobian can be read from that
!!   main file. 
!!   This inversion grid only works, if the very same specfem3dForASKI main file (!) is used for (SPECFEM3D type!) wavefield points!
!!   This means, that this type of inversion grid is ONLY to be used along with METHOD = SPECFEM3D, obviously.
!!   The specfem3dInversionGrid may also be used with integration weights of types other than type 6 (external 
!!   integration weights), but it is recommended to use type 6 integration weights when using specfem3d inversion
!!   grid!, because this assures the best integration there is for this case.
!!   The vtk cell geometry point information is taken from the wavefield points (GLL points) coordinates and the
!!   localization of wavefield points (GLL points) inside the cells is trivial (as all GLL points contained in a 
!!   cell are assumed in a row)
!!
!! \author Florian Schumacher
!! \date Nov 2015
!
module specfem3dInversionGrid
!
  use specfem3dForASKIFiles
  use inputParameter
  use vectorPointer
  use mathConstants
  use errorMessage
!
  implicit none
!
  type specfem3d_inversion_grid
     private
     logical :: is_defined = .false. !< flag indicating the correct definition (initialization) of the object (i.e. all following values)
!
     integer :: specfem_version = 0 !< 1 = SPECFEM3D_GLOBE, 2 = SPEECFEM3D_Cartesian
!
     ! GLL POINTS
     integer :: NGLLX,NGLLY,NGLLZ
     real, dimension(:), pointer :: jacobian => null() !< (NGLLX*NGLLY*NGLLZ*ncell)- array containing the jacobian values for all points
     real, dimension(:), pointer :: xigll => null() !< (NGLLX)-array containing the standard xi GLL coordinates for degree NGLLX-1
     real, dimension(:), pointer :: etagll => null() !< (NGLLY)-array containing the standard eta GLL coordinates for degree NGLLY-1
     real, dimension(:), pointer :: zetagll => null() !< (NGLLZ)-array containing the standard zeta GLL coordinates for degree NGLLZ-1
     real, dimension(:), pointer :: wgllx => null() !< (NGLLX)-array containing the GLL weights for degree NGLLX-1
     real, dimension(:), pointer :: wglly => null() !< (NGLLY)-array containing the GLL weights for degree NGLLY-1
     real, dimension(:), pointer :: wgllz => null() !< (NGLLZ)-array containing the GLL weights for degree NGLLZ-1
!
     ! CELLS
     integer :: ncell !< overall number of inversion grid cells
     real, dimension(:,:), pointer :: cell_center => null() !< (3,ncell)-array: for each cell contains xyz coords of cell center
     type(integer_vector_pointer), dimension(:), pointer :: face_neighbour => null() !< for each cell, contains global cell indices of its neighbours
!
     ! VTK CELL DEFINITION
     real, dimension(:,:,:), pointer :: vtk_points => null() !< (3,8,ncell)-array: for each cell the 3 xyz coords of all 8 cell corners (vtk type 12 cell)
!
     ! COORDINATES SPECIFICATION FOR VTK OUTPUT
     logical :: apply_vtk_coords_scaling_factor
     real :: vtk_coords_scaling_factor
     integer :: vtk_geometry_type_int = -1 !< type of vtk geometry:  0 = volumetric cells , 1 = cell center points
     real :: R_EARTH_KM
     ! in the future: there could be flags in parameter file like: DONT_SMOOTH_LAYER_BOUNDARIES, 
     ! or SMOOTHING_BOUNDARY_CONDITIONS which could be taken into account here, and memorized for better handling 
     ! of smoothing conditions in calls to certain routines below
  end type specfem3d_inversion_grid
!
contains
!------------------------------------------------------------------------
!> \brief logical return whether this specfem3d_inversion_grid is able to transform points (of given coords type) to vtk plot projection
!
  function canTransformToVtkPointsOutsideSpecfem3dInversionGrid(this,coords_type) result(l)
    type(specfem3d_inversion_grid) :: this
    character(len=*) :: coords_type
    logical :: l
    ! technically, the specfem3d_inversion_grid has NO capability to transform points to vtk projection which
    ! are outside the inversion grid. However, when using this type of inversion grid, the wavefield points
    ! in use must be from the same simulation, which means that always all wavefield points are inside
    ! the inversion grid, by definition, and there are no empty cells.
    ! Furthermore, the only possible vtk projection is global view, which means that any station and event
    ! coordinates will be plotted to their global coordinates. 
    ! Hence, this routine will have no effect in practical use. Return .false. anyway for safety reasons.
    l = .false.
  end function canTransformToVtkPointsOutsideSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get unit factor of the volume element
!! \param this specfem3d inversion grid
!! \param uf_wp unit factor of wavefield points
!! \param uf_vol unit factor of volume element (return value of this subroutine)
!! \param errmsg error message
!
  subroutine getUnitFactorOfVolumeElementSpecfem3dInversionGrid(this,uf_wp,uf_vol,errmsg)
    type (specfem3d_inversion_grid) :: this
    real :: uf_wp,uf_vol
    type (error_message) :: errmsg
    character (len=50) :: myname = 'getUnitFactorOfVolumeElementSpecfem3dInversionGrid'
!
    call addTrace(errmsg,myname)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    ! The specfem3d inversion grid does not assume specific units for its spatial extension but simply 
    ! assumes that they are the same as for the wavefield point coordinates (which are located inside the
    ! inversion grid cells only according to their pure numerical values). Hence, for this 3D volumetric
    ! inversion grid, the volume element has a unit which is the cube of the unit of the wavefield points.
    select case(this%specfem_version)
    case(version_globe_specfem3d_for_ASKI_files)
       ! SPECFEM3D_GLOBE writes jacobians of the transformation of points in unit km to standart cell.
       ! I.e., for 3D integration, the unit factor of the weights is 1000^3 
       uf_vol = 1.0e9
    case(version_cartesian_specfem3d_for_ASKI_files)
       ! ASKI for SPECFEM3D_Cartesian simply takes the numbers of the mesh coordinates generated by the user.
       ! Hence, for this 3D volumetric inversion grid, the volume element has a unit which is the cube of the 
       ! unit of the wavefield points.
       uf_vol = uf_wp*uf_wp*uf_wp
    end select
  end subroutine getUnitFactorOfVolumeElementSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief map vtk geometry type names to integers
!
  function intGeometryTypeSpecfem3dInversionGrid(vtk_geometry_type_str) result(vtk_geometry_type_int)
    character(len=*), intent(in) :: vtk_geometry_type_str
    integer :: vtk_geometry_type_int
    select case(trim(vtk_geometry_type_str))
    case('CELLS')
       vtk_geometry_type_int = 0
    case('CELL_CENTERS')
       vtk_geometry_type_int = 1
    case default
       vtk_geometry_type_int = -1
    end select
  end function intGeometryTypeSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief create specfem3d inversion grid
!! \details the parameter file given, must contain all necessary parameters to define
!!  an object of this type. 
!! \param this specfem3d inversion grid
!! \param parfile filename of parameter file containing definintion of this inversion grid
!! \param lu file unit to use for reading and writing files
!! \param errmsg error message
!
  subroutine createSpecfem3dInversionGrid(this,parfile,path,lu,errmsg)
    type (specfem3d_inversion_grid) :: this
    character(len=*) :: parfile,path
    integer :: lu
    type (error_message) :: errmsg
    ! local
    character(len=400) :: errstr
    character(len=28) :: myname = 'createSpecfem3dInversionGrid'
    type (input_parameter) :: inpar
    character (len=80), dimension(5) :: inpar_keys
    data inpar_keys/'SPECFEM3D_ASKI_MAIN_FILE','VTK_GEOMETRY_TYPE','SCALE_VTK_COORDS','VTK_COORDS_SCALING_FACTOR',&
         'SPECFEM3D_R_EARTH_KM'/
    integer :: ios,ntot_wp,type_invgrid,ncell
    integer :: n,icell,cell_shift,p1_shift,p2_shift,p3_shift,p4_shift,p5_shift,p6_shift,p7_shift,p8_shift
    integer :: igllx_cc_1,igllx_cc_2,iglly_cc_1,iglly_cc_2,igllz_cc_1,igllz_cc_2,ix,iy,iz,ip
    integer, dimension(:), allocatable :: igll_cc_mean
    real :: cc_mean_factor
    real, dimension(:), pointer :: x,y,z
!
    nullify(x,y,z)
!
    call addTrace(errmsg,myname)
    if(this%is_defined) then
       call add(errmsg,1,"this object is already defined, deallocating it now before creating new one",myname)
       call deallocateSpecfem3dInversionGrid(this)
    end if
!
    call createKeywordsInputParameter(inpar,inpar_keys)
    call readSubroutineInputParameter(inpar,lu,parfile,errmsg)
    if (.level.errmsg == 2) return
!
    call readSpecfem3dForASKIMainFile(trim(path)//trim(inpar.sval.'SPECFEM3D_ASKI_MAIN_FILE'),lu,errmsg,&
         specfem_version=this%specfem_version,type_inversion_grid=type_invgrid,nwp=ntot_wp,x=x,y=y,z=z,&
         ngllx=this%NGLLX,nglly=this%NGLLY,ngllz=this%NGLLZ,jacobian=this%jacobian,ncell=ncell,nb_idx=this%face_neighbour)
    if(.level.errmsg == 2) goto 1
!
    select case(this%specfem_version)
    case(version_globe_specfem3d_for_ASKI_files)
       this%R_EARTH_KM = rval(inpar,'SPECFEM3D_R_EARTH_KM',iostat=ios)
       if(ios /= 0) then
          call add(errmsg,2,"could not read real value for 'SPECFEM3D_R_EARTH_KM' from '"//&
               trim(inpar.sval.'SPECFEM3D_R_EARTH_KM')//"'",myname)
          goto 1
       end if
    case(version_cartesian_specfem3d_for_ASKI_files)
       this%R_EARTH_KM = 0 ! ignore value, REARTH is not used for vtk output
    case default
       write(errstr,*) "readSpecfem3dForASKIMainFile returned specfem_version = ",this%specfem_version,&
            "; this module only supports specfem versions ",version_globe_specfem3d_for_ASKI_files," = SPECFEM3D_GLOBE and ",&
            version_cartesian_specfem3d_for_ASKI_files," = SPECFEM3D_Cartesian ."
       call add(errmsg,2,errstr,myname)
       goto 1
    end select
! 
    select case(type_invgrid)
    case(4)
       ! OK, so pass doing nothing
    case default
       write(errstr,*) "type of inversion grid = ",type_invgrid," is not supported by specfem3dInversionGrid, must be 4"
       call add(errmsg,2,errstr,myname)
       goto 1
    end select
!
    if(ntot_wp <= 0) then
       write(errstr,*) "readSpecfem3dForASKIMainFile returned number of wavefield points = ",ntot_wp,". Must be positive"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    if(.not.(associated(x).and.associated(y).and.associated(z))) then
       call add(errmsg,2,"readSpecfem3dForASKIMainFile did not return all of x,y,z vectors",myname)
       goto 1
    end if
    if(size(x)/=ntot_wp .or. size(y)/=ntot_wp .or. size(z)/=ntot_wp) then
       write(errstr,*) "readSpecfem3dForASKIMainFile returned vectors x,y,z which do not all have expected size ",ntot_wp
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
!
    if(this%NGLLX<2 .or. this%NGLLY<2 .or. this%NGLLZ<2) then
       write(errstr,*) "NGLLX,NGLLY,NGLLZ =",this%NGLLX,this%NGLLY,this%NGLLZ," must at least be 2"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    if(this%NGLLX>8 .or. this%NGLLY>8 .or. this%NGLLZ>8) then
       write(errstr,*) "NGLLX,NGLLY,NGLLZ =",this%NGLLX,this%NGLLY,this%NGLLZ,&
            " cannot be larger than 8, no support implemented yet. however, "//&
            "this support can be easily implemented, just do it"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    if(mod(ntot_wp,this%NGLLX*this%NGLLY*this%NGLLZ) /= 0) then
       write(errstr,*) "the total number of wavefield points ",ntot_wp," must be a multiple of NGLLX*NGLLY*NGLLZ =",&
            this%NGLLX*this%NGLLY*this%NGLLZ," (namely ncell-times)"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    this%ncell = ntot_wp/(this%NGLLX*this%NGLLY*this%NGLLZ)
!
    allocate(this%xigll(this%NGLLX),this%etagll(this%NGLLY),this%zetagll(this%NGLLZ),&
         this%wgllx(this%NGLLX),this%wglly(this%NGLLY),this%wgllz(this%NGLLZ))
    ! GLL weights and xi,eta,zeta coordinates for GLL quadrature of orders 2-7 taken from thesis:
    !   Schuberth, B., "The Spectral Element Method for Seismic Wave Propagation - Theory, 
    !   Implementation and Comparison to Finite Difference Methods", Diploma Thesis, Dept. 
    !   for Earth and Environmental Sciences, Ludwig-Maximilians-Universität München, (2003)
    select case(this%NGLLX)
    case(2)
       this%xigll = (/ -1., 1. /)
       this%wgllx = (/ 1., 1. /)
    case(3)
       this%xigll = (/ -1., 0., 1. /)
       this%wgllx = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%xigll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wgllx = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%xigll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wgllx = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%xigll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wgllx = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%xigll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wgllx = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%xigll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wgllx = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
    select case(this%NGLLY)
    case(2)
       this%etagll = (/ -1., 1. /)
       this%wglly = (/ 1., 1. /)
    case(3)
       this%etagll = (/ -1., 0., 1. /)
       this%wglly = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%etagll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wglly = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%etagll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wglly = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%etagll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wglly = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%etagll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wglly = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%etagll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wglly = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
    select case(this%NGLLZ)
    case(2)
       this%zetagll = (/ -1., 1. /)
       this%wgllz = (/ 1., 1. /)
    case(3)
       this%zetagll = (/ -1., 0., 1. /)
       this%wgllz = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%zetagll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wgllz = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%zetagll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wgllz = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%zetagll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wgllz = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%zetagll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wgllz = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%zetagll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wgllz = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
!
    if(.not.associated(this%jacobian)) then
       call add(errmsg,2,"readSpecfem3dForASKISpectralWavefieldFile did not return jacobian",myname)
       goto 1
    end if
    if(size(this%jacobian) /= ntot_wp) then
       write(errstr,*) "readSpecfem3dForASKISpectralWavefieldFile returned jacobian of size ",&
            size(this%jacobian),"; expected size ",ntot_wp
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
!
    if(ncell/=this%ncell) then
       write(errstr,*) "the total number of cells ",ncell," contained in main file does not match "//&
            "the total number of cells ",this%ncell," which computes from the number of wavefield points ",&
            ntot_wp," divided by NGLLX*NGLLY*NGLLZ=",this%NGLLX*this%NGLLY*this%NGLLZ
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
!
    if(.not.associated(this%face_neighbour)) then
       call add(errmsg,2,"readSpecfem3dForASKISpectralWavefieldFile did not return invgrid cell neighbours",myname)
       goto 1
    end if
    if(size(this%face_neighbour)/=this%ncell) then
       write(errstr,*) "readSpecfem3dForASKISpectralWavefieldFile returned invgrid cell neighbours of size ",&
            size(this%face_neighbour),"; expected size ",this%ncell
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
!
    ! define vtk geometry
    allocate(this%vtk_points(3,8,this%ncell))
    ! inside an element, the wavefield points are assumed in GLL order. Hence, define wavefield point indices
    ! for all 8 cornerpoints relative to an element
    p1_shift = 1
    p2_shift = this%NGLLX
    p3_shift = this%NGLLX*this%NGLLY
    p4_shift = (this%NGLLY-1)*this%NGLLX + 1
    n = (this%NGLLZ-1)*this%NGLLX*this%NGLLY ! number of points in all but one XY layer
    p5_shift = n + p1_shift ! above point 1
    p6_shift = n + p2_shift ! above point 2
    p7_shift = n + p3_shift ! above point 3
    p8_shift = n + p4_shift ! above point 4
    n = this%NGLLX*this%NGLLY*this%NGLLZ ! compute this product here once, using it in loop below (for performance reasons)
    do icell = 1,this%ncell
       ! assuming vtk cell type 12 here, 8-node hexahedron
       cell_shift = (icell-1)*n ! compute index in arrays x,y,z, where this element starts (minus 1)
       ! vtk point 1
       this%vtk_points(1,1,icell) = x(cell_shift + p1_shift)
       this%vtk_points(2,1,icell) = y(cell_shift + p1_shift)
       this%vtk_points(3,1,icell) = z(cell_shift + p1_shift)
       ! vtk point 2
       this%vtk_points(1,2,icell) = x(cell_shift + p2_shift)
       this%vtk_points(2,2,icell) = y(cell_shift + p2_shift)
       this%vtk_points(3,2,icell) = z(cell_shift + p2_shift)
       ! vtk point 3
       this%vtk_points(1,3,icell) = x(cell_shift + p3_shift)
       this%vtk_points(2,3,icell) = y(cell_shift + p3_shift)
       this%vtk_points(3,3,icell) = z(cell_shift + p3_shift)
       ! vtk point 4
       this%vtk_points(1,4,icell) = x(cell_shift + p4_shift)
       this%vtk_points(2,4,icell) = y(cell_shift + p4_shift)
       this%vtk_points(3,4,icell) = z(cell_shift + p4_shift)
       ! vtk point 5
       this%vtk_points(1,5,icell) = x(cell_shift + p5_shift)
       this%vtk_points(2,5,icell) = y(cell_shift + p5_shift)
       this%vtk_points(3,5,icell) = z(cell_shift + p5_shift)
       ! vtk point 6
       this%vtk_points(1,6,icell) = x(cell_shift + p6_shift)
       this%vtk_points(2,6,icell) = y(cell_shift + p6_shift)
       this%vtk_points(3,6,icell) = z(cell_shift + p6_shift)
       ! vtk point 7
       this%vtk_points(1,7,icell) = x(cell_shift + p7_shift)
       this%vtk_points(2,7,icell) = y(cell_shift + p7_shift)
       this%vtk_points(3,7,icell) = z(cell_shift + p7_shift)
       ! vtk point 8
       this%vtk_points(1,8,icell) = x(cell_shift + p8_shift)
       this%vtk_points(2,8,icell) = y(cell_shift + p8_shift)
       this%vtk_points(3,8,icell) = z(cell_shift + p8_shift)
    end do ! icell
!
    ! define cell center: for each dimension (i.e. x,y,z) use the center gll point (case ngll odd), 
    ! or the mean over the two points adjacent to the cell center (case ngll even)
    allocate(this%cell_center(3,this%ncell))
    if(mod(this%NGLLX,2) == 1) then
       igllx_cc_1 = (this%NGLLX+1)/2
       igllx_cc_2 = igllx_cc_1
    else
       igllx_cc_1 = this%NGLLX/2
       igllx_cc_2 = igllx_cc_1 + 1
    end if
    if(mod(this%NGLLY,2) == 1) then
       iglly_cc_1 = (this%NGLLY+1)/2
       iglly_cc_2 = iglly_cc_1
    else
       iglly_cc_1 = this%NGLLY/2
       iglly_cc_2 = iglly_cc_1 + 1
    end if
    if(mod(this%NGLLZ,2) == 1) then
       igllz_cc_1 = (this%NGLLZ+1)/2
       igllz_cc_2 = igllz_cc_1
    else
       igllz_cc_1 = this%NGLLZ/2
       igllz_cc_2 = igllz_cc_1 + 1
    end if
    ! inside an element, the wavefield points are assumed in GLL order,
    ! igll_cc_mean will contain the point indices (relative to a cell) of all points in the cell, 
    ! over which the mean should be computed
    n = (igllx_cc_2-igllx_cc_1+1)*(iglly_cc_2-iglly_cc_1+1)*(igllz_cc_2-igllz_cc_1+1)
    cc_mean_factor = 1./real(n)
    allocate(igll_cc_mean(n))
    n = 0; ip = 0
    do iz = 1,this%NGLLZ
       do iy = 1,this%NGLLY
          do ix = 1,this%NGLLX
             ip = ip + 1
             if(ix >= igllx_cc_1 .and. ix <= igllx_cc_2 .and. &
                iy >= iglly_cc_1 .and. iy <= iglly_cc_2 .and. &
                iz >= igllz_cc_1 .and. iz <= igllz_cc_2) then
                n = n + 1
                igll_cc_mean(n) = ip
             end if
          end do
       end do
    end do
    ! compute this product here once, using it in loop below (for performance reasons)
    n = this%NGLLX*this%NGLLY*this%NGLLZ 
    do icell = 1,this%ncell
       cell_shift = (icell-1)*n ! compute index in arrays x,y,z, where this element starts (minus 1)
       this%cell_center(1,icell) = cc_mean_factor*sum(x(igll_cc_mean+cell_shift))
       this%cell_center(2,icell) = cc_mean_factor*sum(y(igll_cc_mean+cell_shift)) ! build the mean over all necessary points in this cell
       this%cell_center(3,icell) = cc_mean_factor*sum(z(igll_cc_mean+cell_shift))
    end do ! icell
    deallocate(igll_cc_mean)
!
    this%apply_vtk_coords_scaling_factor = lval(inpar,'SCALE_VTK_COORDS',iostat=ios)
    if(ios /= 0) then
       call add(errmsg,2,"could not read logical value for 'SCALE_VTK_COORDS' from '"//&
            trim(inpar.sval.'SCALE_VTK_COORDS')//"'",myname)
       goto 1
    end if
    if(this%apply_vtk_coords_scaling_factor) then
       this%vtk_coords_scaling_factor = rval(inpar,'VTK_COORDS_SCALING_FACTOR',iostat=ios)
       if(ios /= 0) then
          call add(errmsg,2,"could not read real value for 'VTK_COORDS_SCALING_FACTOR' from '"//&
               trim(inpar.sval.'VTK_COORDS_SCALING_FACTOR')//"'",myname)
          goto 1
       end if
    end if
!
    this%vtk_geometry_type_int = intGeometryTypeSpecfem3dInversionGrid(inpar.sval.'VTK_GEOMETRY_TYPE')
    if(this%vtk_geometry_type_int < 0) then
       call add(errmsg,2,"vtk geometry type '"//trim(inpar.sval.'VTK_GEOMETRY_TYPE')//"' is invalid",myname)
       goto 1
    end if
!
    ! if code comes here, everything went alright. indicate so and return
    this%is_defined = .true.
2   if(associated(x)) deallocate(x)
    if(associated(y)) deallocate(y)
    if(associated(z)) deallocate(z)
    return
!
1   call deallocateSpecfem3dInversionGrid(this)
    goto 2
  end subroutine createSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief deallocate simple layered Cartesian inversion grid
!! \param this simple layered Cartesian inversion grid
!
  subroutine deallocateSpecfem3dInversionGrid(this)
    type (specfem3d_inversion_grid) :: this
    integer :: n
    if(associated(this%jacobian)) deallocate(this%jacobian)
    if(associated(this%xigll)) deallocate(this%xigll)
    if(associated(this%etagll)) deallocate(this%etagll)
    if(associated(this%zetagll)) deallocate(this%zetagll)
    if(associated(this%wgllx)) deallocate(this%wgllx)
    if(associated(this%wglly)) deallocate(this%wglly)
    if(associated(this%wgllz)) deallocate(this%wgllz)
    if(associated(this%vtk_points)) deallocate(this%vtk_points)
    if(associated(this%cell_center)) deallocate(this%cell_center)
    if(associated(this%face_neighbour)) then
       do n = 1,size(this%face_neighbour)
          call dealloc(this%face_neighbour(n))
       end do
       deallocate(this%face_neighbour)
    end if
    this%vtk_geometry_type_int = -1
    this%is_defined = .false.
  end subroutine deallocateSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return overall number of invgrid cells, if any
!
  function getNcellSpecfem3dInversionGrid(this) result(ncell)
    type (specfem3d_inversion_grid), intent(in) :: this
    integer :: ncell
    if(this%is_defined) then
       ncell = this%ncell
    else
       ncell = 0
    end if
  end function getNcellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief transform wp,event or station coords to x,y,z coords for vtk application
!! \details in module inversioGrid it was already checked, if coords_type is one of
!!  'wp','event','station' and that c1,c2,c3 are associated and have all same length
!!  also it can be assured that this specfem3d inversion grid is properly defined (otherwise
!!  inversionGrid module would not fork here)
!! \param this specfem3d inversion grid
!! \param c1 vector or first coordinate (contains vtk x-values on exit)
!! \param c2 vector or second coordinate (contains vtk y-values on exit)
!! \param c3 vector or third coordinate (contains vtk z-values on exit)
!! \param coords_type 'wp','event','station'
!! \param errmsg error message
!
  subroutine transformToVtkSpecfem3dInversionGrid(this,c1,c2,c3,coords_type,errmsg)
    type (specfem3d_inversion_grid) :: this
    real, dimension(:), intent(inout) :: c1,c2,c3
    character(len=*) :: coords_type
    type (error_message) :: errmsg
    real, dimension(:), allocatable :: lat,lon,z
!
    call addTrace(errmsg,'transformToVtkSpecfem3dInversionGrid')
!
    ! when using spherical inversion grids, the event and station coordinates
    ! are assumed to be given in spherical coordinates in degrees (and depth / altitude, respectively)
    ! so in case of coords_type = 'event' or 'station', transform the incoming c1,c2,c3 to respective
    ! global Cartesian coordinates first, then execute the transformations below
    if(this%specfem_version == version_globe_specfem3d_for_ASKI_files) then
!
       select case(coords_type)
       case('station','event')
          allocate(lat(size(c1)),lon(size(c1)),z(size(c1)))
          lat = c1; lon = c2; z = c3
          ! first define unit vectors (c1,c2,c3) in global Cartesian coordinates pointing to the direction of the event/station location
          c1 = cos(lat*mc_deg2rad)*cos(lon*mc_deg2rad)
          c2 = cos(lat*mc_deg2rad)*sin(lon*mc_deg2rad)
          c3 = sin(lat*mc_deg2rad)
          ! then scale the unit vectors (c1,c2,c3) according to the incoming third coordinate z
          select case(coords_type)
          case('station')
             ! for station coordinates, the incoming 3rd coordinate is altitude in meters, which here is ignored: so scale to surface of the earth
             c1 = c1 * this%R_EARTH_KM
             c2 = c2 * this%R_EARTH_KM
             c3 = c3 * this%R_EARTH_KM
          case('event')
             ! for event coordinates, the incoming 3rd coordinate is depth in km
             c1 = c1 * (this%R_EARTH_KM-z)
             c2 = c2 * (this%R_EARTH_KM-z)
             c3 = c3 * (this%R_EARTH_KM-z)
          end select
          deallocate(lat,lon,z)
       end select
!
    end if ! this%specfem_version == version_globe_specfem3d_for_ASKI_files
!
    ! when using Cartesian specfem, there is no need of selecting coords_type: 
    ! always do the same, since the wavefield points as well as event and station coordinates
    ! are expected as x,y,z coordinates (in that order)
!
    if(this%apply_vtk_coords_scaling_factor) then
       c1 = c1 * this%vtk_coords_scaling_factor
       c2 = c2 * this%vtk_coords_scaling_factor
       c3 = c3 * this%vtk_coords_scaling_factor
    end if
  end subroutine transformToVtkSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return geometry information on cells for vtk output
!
  subroutine getGeometryVtkSpecfem3dInversionGrid(this,geometry_type,points,cell_connectivity,cell_type,cell_indx_out,errmsg,&
       cell_indx_req,indx_map_out)
    type (specfem3d_inversion_grid) :: this
    integer :: geometry_type
    integer, dimension(:), optional :: cell_indx_req
    ! outgoing
    real, dimension(:,:), pointer :: points
    integer, dimension(:), pointer :: cell_connectivity,cell_type,cell_indx_out
    integer, dimension(:), pointer, optional :: indx_map_out
    type (error_message) :: errmsg
    ! local
    character(len=36) :: myname = 'getGeometryVtkSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: size_cell_indx_req,i,ncell_return,icell,jcell,ncell_con
    logical, dimension(:), allocatable :: valid_non_duplicate_cell_indx_req
    real :: c1,c2,c3
!
    call addTrace(errmsg,myname)
    nullify(points,cell_connectivity,cell_type,cell_indx_out)
    if(present(indx_map_out)) nullify(indx_map_out)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    if(present(cell_indx_req)) then
       ! if cell_indx_req is present and there are any indices in valid range, select those specific cells
       ! and remove duplicate indices from cell_indx_req. otherwise return no cells (nullified pointers)
       ! HOWEVER, the general order of the returned cell indices is not changed, only gaps of invalid/duplicate
       ! indices in cell_indx_req are closed! (this approach is different from e.g. scartInversionGrid, where
       ! valid/non-duplicate indices in cell_indx_req are always returned sorted w.r.t. the internal cell order)
       size_cell_indx_req = size(cell_indx_req)
       allocate(valid_non_duplicate_cell_indx_req(size_cell_indx_req))
!
       ! first select valid indices
       valid_non_duplicate_cell_indx_req = cell_indx_req .ge. 1 .and. cell_indx_req .le. this%ncell
!
       ! then make all duplicate indices also invalid
       do i = 1,size_cell_indx_req-1
          if(valid_non_duplicate_cell_indx_req(i)) then
             where(cell_indx_req(i+1:size_cell_indx_req) == cell_indx_req(i))
                valid_non_duplicate_cell_indx_req(i+1:size_cell_indx_req) = .false.
             end where
          end if
       end do ! i
!
       ncell_return = count(valid_non_duplicate_cell_indx_req)
       if(ncell_return == 0) then
          deallocate(valid_non_duplicate_cell_indx_req)
          write(errstr,*) "there are no valid indices among requested cell indices; indices must be between 1 and ",&
               this%ncell
          call add(errmsg,2,errstr,myname)
          return
       endif
!
       ! define arrays cell_indx_out, indx_map_out
       allocate(cell_indx_out(ncell_return))
       cell_indx_out = pack(cell_indx_req , valid_non_duplicate_cell_indx_req)
       if(present(indx_map_out)) then
          allocate(indx_map_out(ncell_return))
          indx_map_out = pack( (/ (i,i=1,size_cell_indx_req) /) , valid_non_duplicate_cell_indx_req)
       end if
!
       deallocate(valid_non_duplicate_cell_indx_req)
!
    else ! present(cell_indx_req)
       ! return all cells in the order of inversion grid cells, hence arrays cell_indx_out
       ! and indx_map_out are trivial
       allocate(cell_indx_out(this%ncell))
       cell_indx_out = (/ (i,i=1,this%ncell) /)
       if(present(indx_map_out)) then
          allocate(indx_map_out(this%ncell))
          indx_map_out = cell_indx_out
       end if
       ncell_return = this%ncell
!
    end if ! present(cell_indx_req)
!
    select case(this%vtk_geometry_type_int)
    case(0) ! CELLS
       ! define arrays points,cell_type,cell_connectivity
       allocate(points(3,8*ncell_return),cell_type(ncell_return),cell_connectivity((8+1)*ncell_return))
       cell_type = 12
       ! loop on cell_indx_out
       ncell_con = 0 ! counter on entries in connectivity array
       do icell = 1,ncell_return; jcell = cell_indx_out(icell)
          ! for each cell, store all its 8 points (do not search for common points of cells)
          points(1:3,(icell-1)*8+1:icell*8) = this%vtk_points(1:3,1:8,jcell)
          ! in cell_connectivity, refer the very points just defined 
          cell_connectivity((icell-1)*9+1) = 8
          cell_connectivity((icell-1)*9+2:icell*9) = (/ (i,i=(icell-1)*8,icell*8-1) /) !(note, that for vtk format, point indices have offset 0!)
       end do ! icell
       geometry_type = 0
!
    case(1) ! CELL CENTERS
       ! do not define arrays cell_connectivity and cell_type in this case. Only return points as cell centers
       allocate(points(3,ncell_return))
       do icell = 1,ncell_return
          call getCenterCellSpecfem3dInversionGrid(this,cell_indx_out(icell),c1,c2,c3,'wp')
          points(1,icell) = c1
          points(2,icell) = c2
          points(3,icell) = c3
       end do ! icell
       geometry_type = 1
    end select ! this%vtk_geometry_type
!
    if(this%apply_vtk_coords_scaling_factor) then
       points = points*this%vtk_coords_scaling_factor
    end if
!
  end subroutine getGeometryVtkSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return indices of all face neighbours for all (optionally only subset of) cells
!! \param this specfem3d inversion grid
!! \param nb_idx pointer to array of length this%ncell which contains
!
  subroutine getIndicesFaceNeighboursSpecfem3dInversionGrid(this,nb_idx)
    type (specfem3d_inversion_grid) :: this
    type (integer_vector_pointer), dimension(:), pointer :: nb_idx
    ! local
    integer :: icell
    integer, dimension(:), pointer :: nb,nb2
!
    nullify(nb,nb2)
!
    nullify(nb_idx)
    if(.not.this%is_defined) return
!
    allocate(nb_idx(this%ncell))
    do icell = 1,this%ncell
       nb => getVectorPointer(this%face_neighbour(icell))
       if(associated(nb)) then
          allocate(nb2(size(nb))); nb2 = nb
          call associateVectorPointer(nb_idx(icell),nb2)
          nullify(nb,nb2)
       end if
    end do ! icell
!
  end subroutine getIndicesFaceNeighboursSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief for each cell return indices of wavefield points contained in that cell
!! \param this specfem3d inversion grid
!! \param x vector or first coordinate of wavefield points
!! \param y vector or second coordinate of wavefield points
!! \param z vector or third coordinate of wavefield points
!! \param wp_idx pointer to array of length .ncell.this; if invgrid not defined yet, nullified on exit
!! \param errmsg error message
!
  subroutine locateWpInsideSpecfem3dInversionGrid(this,x,y,z,wp_idx,errmsg)
    type (specfem3d_inversion_grid) :: this
    real, dimension(:), intent(in) :: x,y,z
    type (integer_vector_pointer), dimension(:), pointer :: wp_idx
    type (error_message) :: errmsg
    ! local
    character(len=36) :: myname = 'locateWpInsideSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: nwp,ip,icell,ngll_per_element
    logical :: xyz_inconsistent
    integer, dimension(:), pointer :: idx
!
    nullify(idx)
!
    call addTrace(errmsg,myname)
    nullify(wp_idx)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    ! in routine locateWpInsideInversionGrid of module inversionGrid it was already assured
    ! that x,y,z contain values and are all of same length!
    nwp = size(x)
    ngll_per_element = this%NGLLX*this%NGLLY*this%NGLLZ
    if(nwp /= this%ncell*ngll_per_element) then
       write(errstr,*) "number of incoming wavefield points (",nwp,&
            ") does not match number of wavefield points used to construct this inversion grid (",&
            this%ncell*ngll_per_element,"): inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file"
       call add(errmsg,2,errstr,myname)
       return
    end if
!
    ! we could check the (first few?, e.g. first cell) coordinates, stored in this%vtk_point, if they match the values in x,y,z to be sure
    ! check the corners of the first cell. if wavefield points were read from the very same file, the floating point representations
    ! should be exactly the same as here (so check with "/=" makes sense)
    xyz_inconsistent = .false.
    ip = 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,1,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,1,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,1,1) /= z(ip)
    ip = this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,2,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,2,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,2,1) /= z(ip)
    ip = this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,3,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,3,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,3,1) /= z(ip)
    ip = (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,4,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,4,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,4,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,5,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,5,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,5,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,6,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,6,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,6,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,7,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,7,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,7,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,8,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,8,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,8,1) /= z(ip)
!
    if(xyz_inconsistent) then
       call add(errmsg,2,"incoming wavefield point coordinates of corner points of first cell do not "//&
            "match GLL points from which cell was constructed: inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file",myname)
       return
    end if
!
    allocate(wp_idx(this%ncell))
!
    do icell = 1,this%ncell
       allocate(idx(ngll_per_element))
       idx = (/ (ip,ip=(icell-1)*ngll_per_element+1,icell*ngll_per_element) /)
       call associateVectorPointer(wp_idx(icell),idx)
    end do ! icell
  end subroutine locateWpInsideSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief transform given coordinates of points contained in cell icell to standard cell and compute their jacobian
!! \param this specfem3d inversion grid
!! \param icell global inversion grid cell index
!! \param x vector of global x coordinate (contains x-values in standard cell on exit)
!! \param y vector of global y coordinate (contains y-values in standard cell on exit)
!! \param z vector of global z coordinate (contains z-values in standard cell on exit)
!! \param jacobian contains the actual integration weights!! (cannot communicate NGLLX,NGLLY,NGLLZ to module integrationWeights)
!! \param type_standard_cell defines the shape of the standard cell, select specific routine dependent on type (4=Tetrahedron,6=Hexahedron)
!! \param errmsg error message
!
  subroutine transformToStandardCellSpecfem3dInversionGrid(this,icell,x,y,z,jacobian,type_standard_cell,errmsg)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    integer :: type_standard_cell
    real, dimension(:), intent(inout) :: x,y,z,jacobian
    type (error_message) :: errmsg
    ! local
    character (len=45) :: myname = 'transformToStandardCellSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: nwp,ip,ishift,ngll_per_element,ix,iy,iz
    logical :: xyz_inconsistent
!
    call addTrace(errmsg,myname)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    ! in routine transformToStandardCellInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined, icell is valid and that x,y,z contain values and are all of same length!
    nwp = size(x)
!
    ngll_per_element = this%NGLLX*this%NGLLY*this%NGLLZ
    if(nwp/=ngll_per_element) then
       write(errstr,*) "number of incoming wavefield points ",nwp," of ",icell,"'th inversion grid cell "//&
            "does not match number of GLL points ",ngll_per_element," contained in a cell: "//&
            "inversion grid and wavefield points are inconsistent, must be constructed from the very same "//&
            "specfem3dForASKI main file"
       call add(errmsg,2,errstr,myname)
       return
    end if
!
    ! We could check the (first few?, e.g. first cell) coordinates, stored in this%vtk_point, if they match the values in x,y,z to be sure.
    ! Here we check the corners of the incoming cell. if wavefield points were read from the very same file, the floating point representations
    ! should be exactly the same as here (so check with "/=" makes sense and should work)
    xyz_inconsistent = .false.
    ip = 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,1,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,1,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,1,icell) /= z(ip)
    ip = this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,2,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,2,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,2,icell) /= z(ip)
    ip = this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,3,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,3,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,3,icell) /= z(ip)
    ip = (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,4,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,4,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,4,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,5,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,5,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,5,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,6,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,6,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,6,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,7,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,7,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,7,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,8,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,8,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,8,icell) /= z(ip)
!
    if(xyz_inconsistent) then
       call add(errmsg,2,"incoming wavefield point coordinates of corner points of first cell do not "//&
            "match GLL points from which cell was constructed: inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file",myname)
       return
    end if
!
    ! IF TYPE_STANDARD_CELL == -1 :
    !   As the standard interfaces to module integrationWeights do not permitt to communicate
    !   NGLLX,NGLLY,NGLLZ (in that case, module integrationWeights could have implemented (hardcoded) the
    !   standard GLL weights and compute the weights on its own), we communicate the weights
    !   via the variable jacobian. 
    !   In this fashion, other methods as well may use their own integration weights
    !   (don't need a new integration weights type for every method that wants to do that)
    !   ALSO RETURN XI,ETA,ZETA IN THIS CASE!
    if(type_standard_cell == -1) then
!
       ! set start index for accessing this%jacobian to last point index of previous cell
       ishift = (icell-1)*ngll_per_element
       ip = 0
       do iz = 1,this%NGLLZ
          do iy = 1,this%NGLLY
             do ix = 1,this%NGLLX
                ip = ip + 1
                jacobian(ip) = this%wgllx(ix)*this%wglly(iy)*this%wgllz(iz)*this%jacobian(ishift+ip)
                x(ip) = this%xigll(ix)
                y(ip) = this%etagll(iy)
                z(ip) = this%zetagll(iz)
             end do
          end do
       end do
!
    ! IF TYPE_STANDARD_CELL /= -1 :
    !   return jacobian and standard-cell coordinates xi,eta,zeta as expected by 
    !   module integrationWeights in case of integration weights types other than 6
    !   this way, all other types of integration weights may be used in combination with a
    !   specfem3dInversionGrid (and necessarily specfem3dWavefieldPoints)
    else ! type_standard_cell == -1
!
       ! set start index for accessing this%jacobian to last point index of previous cell
       ishift = (icell-1)*ngll_per_element
       ip = 0
       do iz = 1,this%NGLLZ
          do iy = 1,this%NGLLY
             do ix = 1,this%NGLLX
                ip = ip + 1
                jacobian(ip) = this%jacobian(ishift+ip)
                x(ip) = this%xigll(ix)
                y(ip) = this%etagll(iy)
                z(ip) = this%zetagll(iz)
             end do
          end do
       end do
!
    end if ! type_standard_cell == -1
!
    type_standard_cell = 6
  end subroutine transformToStandardCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get volume of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which volume should be returned
!! \param volume volume of cell icell
!! \param errmsg error message
!
  subroutine getVolumeCellSpecfem3dInversionGrid(this,icell,volume)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: volume
    ! local
    integer :: ix,iy,iz,ip
!
    ! in routine getVolumeCellInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
!
    volume = 0.
    ! set start index for accessing this%jacobian to last point index of previous cell
    ip = (icell-1)*this%NGLLX*this%NGLLY*this%NGLLZ
    do iz = 1,this%NGLLZ
       do iy = 1,this%NGLLY
          do ix = 1,this%NGLLX
             ip = ip + 1
             volume = volume + this%wgllx(ix)*this%wglly(iy)*this%wgllz(iz)*this%jacobian(ip)
          end do
       end do
    end do
  end subroutine getVolumeCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get center of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which center should be returned
!! \param c1 first coordinate of center of cell icell
!! \param c2 second coordinate of center of cell icell
!! \param c3 third coordinate of center of cell icell
!! \param coords_type 'wp','event','station'; optional request
!
  subroutine getCenterCellSpecfem3dInversionGrid(this,icell,c1,c2,c3,coords_type)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: c1,c2,c3
    character(len=*), optional :: coords_type
    ! local
    double precision :: r,theta,phi
    character(len=7) :: coords_type_tested
!
    ! IN CASE OF SPECFEM3D_Cartesian APPLICATIONS:
    ! no need of selecting coords_type (or even checking if present): 
    ! always do the same, since in case of using the 
    ! specfem3d inversion grid the wavefield points as well as event and station coordinates
    ! are expected as x,y,z coordinates (in that order)
    ! THIS IS NOT VALID FOR SPECFEM3D_GLOBE APPLICATIONS!!
!
    ! in routine getCenterCellInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
    c1 = this%cell_center(1,icell)
    c2 = this%cell_center(2,icell)
    c3 = this%cell_center(3,icell)
!
    if(present(coords_type)) then
       coords_type_tested = coords_type
    else
       coords_type_tested = 'wp'
    end if
!
    ! when using spherical inversion grids, the event and station coordinates
    ! are assumed to be given in spherical coordinates in degrees (and depth / altitude, respectively)
    ! so in case of coords_type = 'event' or 'station', transform the outgoing c1,c2,c3 
    ! further (which at this point are in global Cartesian coordinates, i.e. 'wp'-form)
    if(this%specfem_version == version_globe_specfem3d_for_ASKI_files) then
       select case(coords_type_tested)
       case('station','event')
          ! r = sqrt(x^2+y^2+z^2)
          ! theta = arccos(z/r) \in [0,pi] (d.h. 90deg-theta rechnen!)
          ! phi = atan2(x,y)
          r = dsqrt( dble(c1)*dble(c1) + dble(c2)*dble(c2) + dble(c3)*dble(c3) )
          theta = acos(dble(c3)/r)
          phi = atan2(dble(c1),dble(c2))
       
          ! define the first two coordinates (c1 = latitude in degrees (-90<=c1<=90), c2 = lon in degrees (0<=lon<=360))
          c1 = real( (0.5d0*mc_pid - theta) / mc_deg2radd )
          c2 = real( phi / mc_deg2radd )

          ! define third coordinate (different definition for 'station' than for 'event'):
          ! 'station': put point onto surface of the earth (ignoring altitude [m], which c3 actually means in that case)
          ! 'event': c3 is depth [km]
          select case(coords_type_tested)
          case('station')
             c3 = this%R_EARTH_KM
          case('event')
             c3 = real( dble(this%R_EARTH_KM)-r )
          end select ! coords_type_tested
       end select ! coords_type_tested
    end if ! this%specfem_version == version_globe_specfem3d_for_ASKI_files
!
  end subroutine getCenterCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get radius of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which radius should be returned
!! \param radius radius of cell icell
!
  subroutine getRadiusCellSpecfem3dInversionGrid(this,icell,radius)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: radius
    ! local
    real, dimension(3) :: p1,p2,p3,p4,p5,p6,p7,p8
!
    ! in routine getRadiusCellInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
!
    ! pi is the vector pointing from cell center to i'th cell corner
    p1 = this%vtk_points(:,1,icell) - this%cell_center(:,icell)
    p2 = this%vtk_points(:,2,icell) - this%cell_center(:,icell)
    p3 = this%vtk_points(:,3,icell) - this%cell_center(:,icell)
    p4 = this%vtk_points(:,4,icell) - this%cell_center(:,icell)
    p5 = this%vtk_points(:,5,icell) - this%cell_center(:,icell)
    p6 = this%vtk_points(:,6,icell) - this%cell_center(:,icell)
    p7 = this%vtk_points(:,7,icell) - this%cell_center(:,icell)
    p8 = this%vtk_points(:,8,icell) - this%cell_center(:,icell)
!
    ! return as radius the maximum distance of a corner point from the cell center
    radius = max( sqrt(sum(p1*p1)) , sqrt(sum(p2*p2)) , sqrt(sum(p3*p3)) , sqrt(sum(p4*p4)) , &
                  sqrt(sum(p5*p5)) , sqrt(sum(p6*p6)) , sqrt(sum(p7*p7)) , sqrt(sum(p8*p8)) )
  end subroutine getRadiusCellSpecfem3dInversionGrid
!
end module specfem3dInversionGrid
