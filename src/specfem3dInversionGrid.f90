!----------------------------------------------------------------------------
!   Copyright 2013 Florian Schumacher (Ruhr-Universitaet Bochum, Germany)
!
!   This file is part of ASKI version 0.3.
!
!   ASKI version 0.3 is free software: you can redistribute it and/or modify
!   it under the terms of the GNU General Public License as published by
!   the Free Software Foundation, either version 2 of the License, or
!   (at your option) any later version.
!
!   ASKI version 0.3 is distributed in the hope that it will be useful,
!   but WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   You should have received a copy of the GNU General Public License
!   along with ASKI version 0.3.  If not, see <http://www.gnu.org/licenses/>.
!----------------------------------------------------------------------------
!> \brief inversion grid consisting SPECFEM3D elements as inversion grid cells
!!
!! \details Use the specfem3d for ASKI main file generated by specfem3d-for-ASKI using ASKI_type_inversion_grid = 4,
!!   which contains wavefield points for complete elements (all GLL points, in fact)
!!   and they are stored in order as handled in specfem. Furthermore their values of jacobian can be read from that
!!   main file. 
!!   This inversion grid only works, if the very same specfem3dForASKI main file (!) is used for (SPECFEM3D type!) wavefield points!
!!   This means, that this type of inversion grid is ONLY to be used along with METHOD = SPECFEM3D, obviously.
!!   The specfem3dInversionGrid may also be used with integration weights of types other than type 6 (external 
!!   integration weights), but it is recommended to use type 6 integration weights when using specfem3d inversion
!!   grid!, because this assures the best integration there is for this case.
!!   The vtk cell geometry point information is taken from the wavefield points (GLL points) coordinates and the
!!   localization of wavefield points (GLL points) inside the cells is trivial (as all GLL points contained in a 
!!   cell are assumed in a row)
!!
!! \author Florian Schumacher
!! \date Jul 2013
!
module specfem3dInversionGrid
!
  use inputParameter
  use vectorPointer
  use errorMessage
!
  implicit none
!
  type specfem3d_inversion_grid
     private
     logical :: is_defined = .false. !< flag indicating the correct definition (initialization) of the object (i.e. all following values)
!
     ! GLL POINTS
     integer :: NGLLX,NGLLY,NGLLZ
     real, dimension(:), pointer :: jacobian => null() !< (NGLLX*NGLLY*NGLLZ*ncell)- array containing the jacobian values for all points
     real, dimension(:), pointer :: xigll => null() !< (NGLLX)-array containing the standard xi GLL coordinates for degree NGLLX-1
     real, dimension(:), pointer :: etagll => null() !< (NGLLY)-array containing the standard eta GLL coordinates for degree NGLLY-1
     real, dimension(:), pointer :: zetagll => null() !< (NGLLZ)-array containing the standard zeta GLL coordinates for degree NGLLZ-1
     real, dimension(:), pointer :: wgllx => null() !< (NGLLX)-array containing the GLL weights for degree NGLLX-1
     real, dimension(:), pointer :: wglly => null() !< (NGLLY)-array containing the GLL weights for degree NGLLY-1
     real, dimension(:), pointer :: wgllz => null() !< (NGLLZ)-array containing the GLL weights for degree NGLLZ-1
!
     ! CELLS
     integer :: ncell !< overall number of inversion grid cells
     real, dimension(:,:), pointer :: cell_center => null() !< (3,ncell)-array: for each cell contains xyz coords of cell center
     type(integer_vector_pointer), dimension(:), pointer :: face_neighbour => null() !< for each cell, contains global cell indices of its neighbours
!
     ! VTK CELL DEFINITION
     real, dimension(:,:,:), pointer :: vtk_points => null() !< (3,8,ncell)-array: for each cell the 3 xyz coords of all 8 cell corners (vtk type 12 cell)
!
     ! COORDINATES SPECIFICATION FOR VTK OUTPUT
     logical :: apply_vtk_coords_scaling_factor
     real :: vtk_coords_scaling_factor
     ! in the future: there could be flags in parameter file like: DONT_SMOOTH_LAYER_BOUNDARIES, 
     ! or SMOOTHING_BOUNDARY_CONDITIONS which could be taken into account here, and memorized for better handling 
     ! of smoothing conditions in calls to certain routines below
  end type specfem3d_inversion_grid
!
contains
!------------------------------------------------------------------------
!> \brief create specfem3d inversion grid
!! \details the parameter file given, must contain all necessary parameters to define
!!  an object of this type. 
!! \param this specfem3d inversion grid
!! \param parfile filename of parameter file containing definintion of this inversion grid
!! \param lu file unit to use for reading and writing files
!! \param errmsg error message
!
  subroutine createSpecfem3dInversionGrid(this,parfile,path,lu,errmsg)
    type (specfem3d_inversion_grid) :: this
    character(len=*) :: parfile,path
    integer :: lu
    type (error_message) :: errmsg
    ! local
    character(len=400) :: errstr
    character(len=28) :: myname = 'createSpecfem3dInversionGrid'
    type (input_parameter) :: inpar
    character (len=80), dimension(3) :: inpar_keys
    data inpar_keys/'SPECFEM3D_ASKI_MAIN_FILE','SCALE_VTK_COORDS','VTK_COORDS_SCALING_FACTOR'/
    integer :: ios,ntot_wp,nf,specfem_version,type_invgrid,nproc,len_id
    integer :: n,icell,cell_shift,p1_shift,p2_shift,p3_shift,p4_shift,p5_shift,p6_shift,p7_shift,p8_shift
    integer :: igllx_cc_1,igllx_cc_2,iglly_cc_1,iglly_cc_2,igllz_cc_1,igllz_cc_2,ix,iy,iz,ip
    integer, dimension(:), allocatable :: igll_cc_mean
    real :: cc_mean_factor
    integer :: nnb_total,nnb_count,ncell,nnb
    real :: df
    integer, dimension(:), pointer :: idx
    character(len=1) :: dummy_char
    real, dimension(:), allocatable :: x,y,z
    integer, dimension(:), allocatable :: jf
!
    call addTrace(errmsg,myname)
    if(this%is_defined) then
       call add(errmsg,1,"this object is already defined, deallocating it now before creating new one",myname)
       call deallocateSpecfem3dInversionGrid(this)
    end if
!
    call createKeywordsInputParameter(inpar,inpar_keys)
    call readSubroutineInputParameter(inpar,lu,parfile,errmsg)
    if (.level.errmsg == 2) return
!
    open(unit=lu,file=trim(path)//trim(inpar.sval.'SPECFEM3D_ASKI_MAIN_FILE'),status='old',&
         action='read',access='stream',form='unformatted',iostat=ios)
    if (ios /= 0) then
       call add(errmsg,2,"File '"//trim(parfile)//"' cannot be opened to read",myname)
       goto 1
    endif
!
    read(lu) specfem_version
    select case(specfem_version)
    case(1,2)
       ! OK, so pass doing nothing
    case default
       write(errstr,*) "specfem version = ",specfem_version," is not supported: 1 = SPECFEM3D_GLOBE, 2 = SPECFEM3D_Cartesian"
       call add(errmsg,2,errstr,myname)
       goto 1
    end select
! 
    read(lu) len_id
    if(len_id<1) then
       write(errstr,*) "negative id length ",len_id," in ASKI main file '"//trim(path)//&
            trim(inpar.sval.'SPECFEM3D_ASKI_MAIN_FILE')//"'"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    ! read id character by character
    do n=1,len_id
       read(lu) dummy_char
    end do ! i
!
    read(lu) nproc,type_invgrid,ntot_wp,df,nf
!
    select case(type_invgrid)
    case(4)
       ! OK, so pass doing nothing
    case default
       write(errstr,*) "type of inversion grid = ",type_invgrid," is not supported by specfem3dInversionGrid, must be 4"
       call add(errmsg,2,errstr,myname)
       goto 1
    end select
!
    if(nf<1 .or. ntot_wp<1) then
       write(errstr,*) "ntot_wp,df,nf =",ntot_wp,df,nf,"; ntot_wp and nf should be positive"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    allocate(jf(nf))
    read(lu) jf
    allocate(x(ntot_wp),y(ntot_wp),z(ntot_wp))
    read(lu) x
    read(lu) y
    read(lu) z
    read(lu) this%NGLLX,this%NGLLY,this%NGLLZ
    if(this%NGLLX<2 .or. this%NGLLY<2 .or. this%NGLLZ<2) then
       write(errstr,*) "NGLLX,NGLLY,NGLLZ =",this%NGLLX,this%NGLLY,this%NGLLZ," must at least be 2"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    if(this%NGLLX>8 .or. this%NGLLY>8 .or. this%NGLLZ>8) then
       write(errstr,*) "NGLLX,NGLLY,NGLLZ =",this%NGLLX,this%NGLLY,this%NGLLZ,&
            " cannot be larger than 8, no support implemented yet. however, "//&
            "this support can be easily implemented, just do it"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    if(mod(ntot_wp,this%NGLLX*this%NGLLY*this%NGLLZ) /= 0) then
       write(errstr,*) "the total number of wavefield points ",ntot_wp," must be a multiple of NGLLX*NGLLY*NGLLZ =",&
            this%NGLLX*this%NGLLY*this%NGLLZ," (namely ncell-times)"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    this%ncell = ntot_wp/(this%NGLLX*this%NGLLY*this%NGLLZ)
!
    allocate(this%xigll(this%NGLLX),this%etagll(this%NGLLY),this%zetagll(this%NGLLZ),&
         this%wgllx(this%NGLLX),this%wglly(this%NGLLY),this%wgllz(this%NGLLZ))
    ! GLL weights and xi,eta,zeta coordinates for GLL quadrature of orders 2-7 taken from thesis:
    !   Schuberth, B., "The Spectral Element Method for Seismic Wave Propagation - Theory, 
    !   Implementation and Comparison to Finite Difference Methods", Diploma Thesis, Dept. 
    !   for Earth and Environmental Sciences, Ludwig-Maximilians-Universität München, (2003)
    select case(this%NGLLX)
    case(2)
       this%xigll = (/ -1., 1. /)
       this%wgllx = (/ 1., 1. /)
    case(3)
       this%xigll = (/ -1., 0., 1. /)
       this%wgllx = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%xigll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wgllx = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%xigll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wgllx = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%xigll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wgllx = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%xigll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wgllx = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%xigll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wgllx = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
    select case(this%NGLLY)
    case(2)
       this%etagll = (/ -1., 1. /)
       this%wglly = (/ 1., 1. /)
    case(3)
       this%etagll = (/ -1., 0., 1. /)
       this%wglly = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%etagll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wglly = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%etagll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wglly = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%etagll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wglly = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%etagll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wglly = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%etagll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wglly = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
    select case(this%NGLLZ)
    case(2)
       this%zetagll = (/ -1., 1. /)
       this%wgllz = (/ 1., 1. /)
    case(3)
       this%zetagll = (/ -1., 0., 1. /)
       this%wgllz = (/ 0.333333333, 1.333333333, 0.333333333 /)
    case(4)
       this%zetagll = (/ -1., -0.447213595, 0.447213595, 1. /)
       this%wgllz = (/ 0.166666666, 0.833333333, 0.833333333, 0.166666666 /)
    case(5)
       this%zetagll = (/ -1., -0.654653671, 0., 0.654653671, 1. /)
       this%wgllz = (/ 0.100000000, 0.544444444, 0.711111111, 0.544444444, &
            0.100000000 /)
    case(6)
       this%zetagll = (/ -1., -0.765055324, -0.285231516, 0.285231516, 0.765055324, 1. /)
       this%wgllz = (/ 0.066666666, 0.378474956, 0.554858377, 0.554858377, &
            0.378474956, 0.066666666 /)
    case(7)
       this%zetagll = (/ -1., -0.830223896, -0.468848793, 0., 0.468848793, 0.830223896, 1. /)
       this%wgllz = (/ 0.047619048, 0.276826047, 0.431745381, 0.487619047, &
            0.431745381, 0.276826047, 0.047619048 /)
    case(8)
       this%zetagll = (/ -1., -0.871740149, -0.591700181, -0.209299218, 0.209299218, &
            0.591700181, 0.871740149, 1. /)
       this%wgllz = (/ 0.035714286, 0.210704227, 0.341122692, 0.412458795, &
            0.412458795, 0.341122692, 0.210704227, 0.035714286 /)
    end select
!
    allocate(this%jacobian(ntot_wp))
    read(lu) this%jacobian
!
    ! read in information on neighbours
    read(lu) ncell,nnb_total
    if(ncell/=this%ncell) then
       write(errstr,*) "the total number of cells ",ncell," contained in main file does not match "//&
            "the total number of cells ",this%ncell," which computes from the number of wavefield points ",&
            ntot_wp," divided by NGLLX*NGLLY*NGLLZ=",this%NGLLX*this%NGLLY*this%NGLLZ
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
    allocate(this%face_neighbour(this%ncell))
    nnb_count = 0
    do icell=1,this%ncell
       read(lu) nnb; nnb_count=nnb_count+1
       if(nnb>0) then
          allocate(idx(nnb))
          read(lu) idx
          call associateVectorPointer(this%face_neighbour(icell),idx); nullify(idx)
          nnb_count=nnb_count+nnb
       end if
    end do ! icell
    if(nnb_count /= nnb_total) then
       write(errstr,*) "the total number of integers in main file containing neighbour information ",nnb_count,&
            " does not match the expected number of integers ",nnb_total,"; file is inconsistent!"
       call add(errmsg,2,errstr,myname)
       goto 1
    end if
!
    ! define vtk geometry
    allocate(this%vtk_points(3,8,this%ncell))
    ! inside an element, the wavefield points are assumed in GLL order. Hence, define wavefield point indices
    ! for all 8 cornerpoints relative to an element
    p1_shift = 1
    p2_shift = this%NGLLX
    p3_shift = this%NGLLX*this%NGLLY
    p4_shift = (this%NGLLY-1)*this%NGLLX + 1
    n = (this%NGLLZ-1)*this%NGLLX*this%NGLLY ! number of points in all but one XY layer
    p5_shift = n + p1_shift ! above point 1
    p6_shift = n + p2_shift ! above point 2
    p7_shift = n + p3_shift ! above point 3
    p8_shift = n + p4_shift ! above point 4
    n = this%NGLLX*this%NGLLY*this%NGLLZ ! compute this product here once, using it in loop below (for performance reasons)
    do icell = 1,this%ncell
       ! assuming vtk cell type 12 here, 8-node hexahedron
       cell_shift = (icell-1)*n ! compute index in arrays x,y,z, where this element starts (minus 1)
       ! vtk point 1
       this%vtk_points(1,1,icell) = x(cell_shift + p1_shift)
       this%vtk_points(2,1,icell) = y(cell_shift + p1_shift)
       this%vtk_points(3,1,icell) = z(cell_shift + p1_shift)
       ! vtk point 2
       this%vtk_points(1,2,icell) = x(cell_shift + p2_shift)
       this%vtk_points(2,2,icell) = y(cell_shift + p2_shift)
       this%vtk_points(3,2,icell) = z(cell_shift + p2_shift)
       ! vtk point 3
       this%vtk_points(1,3,icell) = x(cell_shift + p3_shift)
       this%vtk_points(2,3,icell) = y(cell_shift + p3_shift)
       this%vtk_points(3,3,icell) = z(cell_shift + p3_shift)
       ! vtk point 4
       this%vtk_points(1,4,icell) = x(cell_shift + p4_shift)
       this%vtk_points(2,4,icell) = y(cell_shift + p4_shift)
       this%vtk_points(3,4,icell) = z(cell_shift + p4_shift)
       ! vtk point 5
       this%vtk_points(1,5,icell) = x(cell_shift + p5_shift)
       this%vtk_points(2,5,icell) = y(cell_shift + p5_shift)
       this%vtk_points(3,5,icell) = z(cell_shift + p5_shift)
       ! vtk point 6
       this%vtk_points(1,6,icell) = x(cell_shift + p6_shift)
       this%vtk_points(2,6,icell) = y(cell_shift + p6_shift)
       this%vtk_points(3,6,icell) = z(cell_shift + p6_shift)
       ! vtk point 7
       this%vtk_points(1,7,icell) = x(cell_shift + p7_shift)
       this%vtk_points(2,7,icell) = y(cell_shift + p7_shift)
       this%vtk_points(3,7,icell) = z(cell_shift + p7_shift)
       ! vtk point 8
       this%vtk_points(1,8,icell) = x(cell_shift + p8_shift)
       this%vtk_points(2,8,icell) = y(cell_shift + p8_shift)
       this%vtk_points(3,8,icell) = z(cell_shift + p8_shift)
    end do ! icell
!
    ! define cell center: for each dimension (i.e. x,y,z) use the center gll point (case ngll odd), 
    ! or the mean over the two points adjacent to the cell center (case ngll even)
    allocate(this%cell_center(3,this%ncell))
    if(mod(this%NGLLX,2) == 1) then
       igllx_cc_1 = (this%NGLLX+1)/2
       igllx_cc_2 = igllx_cc_1
    else
       igllx_cc_1 = this%NGLLX/2
       igllx_cc_2 = igllx_cc_1 + 1
    end if
    if(mod(this%NGLLY,2) == 1) then
       iglly_cc_1 = (this%NGLLY+1)/2
       iglly_cc_2 = iglly_cc_1
    else
       iglly_cc_1 = this%NGLLY/2
       iglly_cc_2 = iglly_cc_1 + 1
    end if
    if(mod(this%NGLLZ,2) == 1) then
       igllz_cc_1 = (this%NGLLZ+1)/2
       igllz_cc_2 = igllz_cc_1
    else
       igllz_cc_1 = this%NGLLZ/2
       igllz_cc_2 = igllz_cc_1 + 1
    end if
    ! inside an element, the wavefield points are assumed in GLL order,
    ! igll_cc_mean will contain the point indices (relative to a cell) of all points in the cell, 
    ! over which the mean should be computed
    n = (igllx_cc_2-igllx_cc_1+1)*(iglly_cc_2-iglly_cc_1+1)*(igllz_cc_2-igllz_cc_1+1)
    cc_mean_factor = 1./real(n)
    allocate(igll_cc_mean(n))
    n = 0; ip = 0
    do iz = 1,this%NGLLZ
       do iy = 1,this%NGLLY
          do ix = 1,this%NGLLX
             ip = ip + 1
             if(ix >= igllx_cc_1 .and. ix <= igllx_cc_2 .and. &
                iy >= iglly_cc_1 .and. iy <= iglly_cc_2 .and. &
                iz >= igllz_cc_1 .and. iz <= igllz_cc_2) then
                n = n + 1
                igll_cc_mean(n) = ip
             end if
          end do
       end do
    end do
    ! compute this product here once, using it in loop below (for performance reasons)
    n = this%NGLLX*this%NGLLY*this%NGLLZ 
    do icell = 1,this%ncell
       cell_shift = (icell-1)*n ! compute index in arrays x,y,z, where this element starts (minus 1)
       this%cell_center(1,icell) = cc_mean_factor*sum(x(igll_cc_mean+cell_shift))
       this%cell_center(2,icell) = cc_mean_factor*sum(y(igll_cc_mean+cell_shift)) ! build the mean over all necessary points in this cell
       this%cell_center(3,icell) = cc_mean_factor*sum(z(igll_cc_mean+cell_shift))
    end do ! icell
    deallocate(igll_cc_mean)
!
    this%apply_vtk_coords_scaling_factor = lval(inpar,'SCALE_VTK_COORDS',iostat=ios)
    if(ios /= 0) then
       call add(errmsg,2,"could not read logical value for 'SCALE_VTK_COORDS' from '"//&
            trim(inpar.sval.'SCALE_VTK_COORDS')//"'",myname)
       goto 1
    end if
    if(this%apply_vtk_coords_scaling_factor) then
       this%vtk_coords_scaling_factor = rval(inpar,'VTK_COORDS_SCALING_FACTOR',iostat=ios)
       if(ios /= 0) then
          call add(errmsg,2,"could not read real value for 'VTK_COORDS_SCALING_FACTOR' from '"//&
               trim(inpar.sval.'VTK_COORDS_SCALING_FACTOR')//"'",myname)
          goto 1
       end if
    end if
!
2   close(lu)
    if(allocated(jf)) deallocate(jf)
    if(allocated(x)) deallocate(x)
    if(allocated(y)) deallocate(y)
    if(allocated(z)) deallocate(z)
    this%is_defined = .true.
    return
!
1   call deallocateSpecfem3dInversionGrid(this)
    goto 2
  end subroutine createSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief deallocate simple layered Cartesian inversion grid
!! \param this simple layered Cartesian inversion grid
!
  subroutine deallocateSpecfem3dInversionGrid(this)
    type (specfem3d_inversion_grid) :: this
    integer :: n
    if(associated(this%jacobian)) deallocate(this%jacobian)
    if(associated(this%xigll)) deallocate(this%xigll)
    if(associated(this%etagll)) deallocate(this%etagll)
    if(associated(this%zetagll)) deallocate(this%zetagll)
    if(associated(this%wgllx)) deallocate(this%wgllx)
    if(associated(this%wglly)) deallocate(this%wglly)
    if(associated(this%wgllz)) deallocate(this%wgllz)
    if(associated(this%vtk_points)) deallocate(this%vtk_points)
    if(associated(this%cell_center)) deallocate(this%cell_center)
    if(associated(this%face_neighbour)) then
       do n = 1,size(this%face_neighbour)
          call dealloc(this%face_neighbour(n))
       end do
       deallocate(this%face_neighbour)
    end if
    this%is_defined = .false.
  end subroutine deallocateSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return overall number of invgrid cells, if any
!
  function getNcellSpecfem3dInversionGrid(this) result(ncell)
    type (specfem3d_inversion_grid), intent(in) :: this
    integer :: ncell
    if(this%is_defined) then
       ncell = this%ncell
    else
       ncell = 0
    end if
  end function getNcellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief transform wp,event or station coords to x,y,z coords for vtk application
!! \details in module inversioGrid it was already checked, if coords_type is one of
!!  'wp','event','station' and that c1,c2,c3 are associated and have all same length
!!  also it can be assured that this specfem3d inversion grid is properly defined (otherwise
!!  inversionGrid module would not fork here)
!! \param this specfem3d inversion grid
!! \param c1 vector or first coordinate (contains vtk x-values on exit)
!! \param c2 vector or second coordinate (contains vtk y-values on exit)
!! \param c3 vector or third coordinate (contains vtk z-values on exit)
!! \param coords_type 'wp','event','station'
!! \param errmsg error message
!
  subroutine transformToVtkSpecfem3dInversionGrid(this,c1,c2,c3,coords_type,errmsg)
    type (specfem3d_inversion_grid) :: this
    real, dimension(:), intent(inout) :: c1,c2,c3
    character(len=*) :: coords_type
    type (error_message) :: errmsg
!
    call addTrace(errmsg,'transformToVtkSpecfem3dInversionGrid')
!
    ! no need of selecting coords_type: always do the same, since in case of using the 
    ! specfem3d inversion grid the wavefield points as well as event and station coordinates
    ! are expected as x,y,z coordinates (in that order)
!
    if(this%apply_vtk_coords_scaling_factor) then
       c1 = c1 * this%vtk_coords_scaling_factor
       c2 = c2 * this%vtk_coords_scaling_factor
       c3 = c3 * this%vtk_coords_scaling_factor
    end if
  end subroutine transformToVtkSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return geometry information on cells for vtk output
!
  subroutine getGeometryVtkSpecfem3dInversionGrid(this,points,cell_connectivity,cell_type,cell_indx_out,errmsg,&
       cell_indx_req,indx_map_out)
    type (specfem3d_inversion_grid) :: this
    integer, dimension(:), optional :: cell_indx_req
    ! outgoing
    real, dimension(:,:), pointer :: points
    integer, dimension(:), pointer :: cell_connectivity,cell_type,cell_indx_out
    integer, dimension(:), pointer, optional :: indx_map_out
    type (error_message) :: errmsg
    ! local
    character(len=36) :: myname = 'getGeometryVtkSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: size_cell_indx_req,i,ncell_return,icell,jcell,ncell_con
    logical, dimension(:), allocatable :: valid_non_duplicate_cell_indx_req
!
    call addTrace(errmsg,myname)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    if(present(cell_indx_req)) then
       ! if cell_indx_req is present and there are any indices in valid range, select those specific cells
       ! and remove duplicate indices from cell_indx_req. otherwise return no cells (nullified pointers)
       ! HOWEVER, the general order of the returned cell indices is not changed, only gaps of invalid/duplicate
       ! indices in cell_indx_req are closed! (this approach is different from e.g. scartInversionGrid, where
       ! valid/non-duplicate indices in cell_indx_req are always returned sorted w.r.t. the internal cell order)
       size_cell_indx_req = size(cell_indx_req)
       allocate(valid_non_duplicate_cell_indx_req(size_cell_indx_req))
!
       ! first select valid indices
       valid_non_duplicate_cell_indx_req = cell_indx_req .ge. 1 .and. cell_indx_req .le. this%ncell
!
       ! then make all duplicate indices also invalid
       do i = 1,size_cell_indx_req-1
          if(valid_non_duplicate_cell_indx_req(i)) then
             where(cell_indx_req(i+1:size_cell_indx_req) == cell_indx_req(i))
                valid_non_duplicate_cell_indx_req(i+1:size_cell_indx_req) = .false.
             end where
          end if
       end do ! i
!
       ncell_return = count(valid_non_duplicate_cell_indx_req)
       if(ncell_return == 0) then
          deallocate(valid_non_duplicate_cell_indx_req)
          write(errstr,*) "there are no valid indices among requested cell indices; indices must be between 1 and ",&
               this%ncell
          call add(errmsg,2,errstr,myname)
          return
       endif
!
       ! define arrays cell_indx_out, indx_map_out
       allocate(cell_indx_out(ncell_return))
       cell_indx_out = pack(cell_indx_req , valid_non_duplicate_cell_indx_req)
       if(present(indx_map_out)) then
          allocate(indx_map_out(ncell_return))
          indx_map_out = pack( (/ (i,i=1,size_cell_indx_req) /) , valid_non_duplicate_cell_indx_req)
       end if
!
       deallocate(valid_non_duplicate_cell_indx_req)
!
    else ! present(cell_indx_req)
       ! return all cells in the order of inversion grid cells, hence arrays cell_indx_out
       ! and indx_map_out are trivial
       allocate(cell_indx_out(this%ncell))
       cell_indx_out = (/ (i,i=1,this%ncell) /)
       if(present(indx_map_out)) then
          allocate(indx_map_out(this%ncell))
          indx_map_out = cell_indx_out
       end if
       ncell_return = this%ncell
!
    end if ! present(cell_indx_req)
!
    ! define arrays points,cell_type,cell_connectivity
    allocate(points(3,8*ncell_return),cell_type(ncell_return),cell_connectivity((8+1)*ncell_return))
    cell_type = 12
    ! loop on cell_indx_out
    ncell_con = 0 ! counter on entries in connectivity array
    do icell = 1,ncell_return; jcell = cell_indx_out(icell)
       ! for each cell, store all its 8 points (do not search for common points of cells)
       points(1:3,(icell-1)*8+1:icell*8) = this%vtk_points(1:3,1:8,jcell)
       ! in cell_connectivity, refer the very points just defined 
       cell_connectivity((icell-1)*9+1) = 8
       cell_connectivity((icell-1)*9+2:icell*9) = (/ (i,i=(icell-1)*8,icell*8-1) /) !(note, that for vtk format, point indices have offset 0!)
    end do ! icell
!
  end subroutine getGeometryVtkSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief return indices of all face neighbours for all (optionally only subset of) cells
!! \param this specfem3d inversion grid
!! \param nb_idx pointer to array of length this%ncell which contains
!
  subroutine getIndicesFaceNeighboursSpecfem3dInversionGrid(this,nb_idx)
    type (specfem3d_inversion_grid) :: this
    type (integer_vector_pointer), dimension(:), pointer :: nb_idx
    ! local
    integer :: icell
    integer, dimension(:), pointer :: nb,nb2
!
    nullify(nb_idx)
    if(.not.this%is_defined) return
!
    allocate(nb_idx(this%ncell))
    do icell = 1,this%ncell
       nb => getVectorPointer(this%face_neighbour(icell))
       if(associated(nb)) then
          allocate(nb2(size(nb))); nb2 = nb
          call associateVectorPointer(nb_idx(icell),nb2)
          nullify(nb,nb2)
       end if
    end do ! icell
!
  end subroutine getIndicesFaceNeighboursSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief for each cell return indices of wavefield points contained in that cell
!! \param this specfem3d inversion grid
!! \param x vector or first coordinate of wavefield points
!! \param y vector or second coordinate of wavefield points
!! \param z vector or third coordinate of wavefield points
!! \param wp_idx pointer to array of length .ncell.this; if invgrid not defined yet, nullified on exit
!! \param errmsg error message
!
  subroutine locateWpInsideSpecfem3dInversionGrid(this,x,y,z,wp_idx,errmsg)
    type (specfem3d_inversion_grid) :: this
    real, dimension(:), intent(in) :: x,y,z
    type (integer_vector_pointer), dimension(:), pointer :: wp_idx
    type (error_message) :: errmsg
    ! local
    character(len=36) :: myname = 'locateWpInsideSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: nwp,ip,icell,ngll_per_element
    logical :: xyz_inconsistent
    integer, dimension(:), pointer :: idx
!
    call addTrace(errmsg,myname)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    ! in routine locateWpInsideInversionGrid of module inversionGrid it was already assured
    ! that x,y,z contain values and are all of same length!
    nwp = size(x)
    ngll_per_element = this%NGLLX*this%NGLLY*this%NGLLZ
    if(nwp /= this%ncell*ngll_per_element) then
       write(errstr,*) "number of incoming wavefield points (",nwp,&
            ") does not match number of wavefield points used to construct this inversion grid (",&
            this%ncell*ngll_per_element,"): inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file"
       call add(errmsg,2,errstr,myname)
       return
    end if
!
    ! we could check the (first few?, e.g. first cell) coordinates, stored in this%vtk_point, if they match the values in x,y,z to be sure
    ! check the corners of the first cell. if wavefield points were read from the very same file, the floating point representations
    ! should be exactly the same as here (so check with "/=" makes sense)
    xyz_inconsistent = .false.
    ip = 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,1,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,1,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,1,1) /= z(ip)
    ip = this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,2,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,2,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,2,1) /= z(ip)
    ip = this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,3,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,3,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,3,1) /= z(ip)
    ip = (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,4,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,4,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,4,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,5,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,5,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,5,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,6,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,6,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,6,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,7,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,7,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,7,1) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,8,1) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,8,1) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,8,1) /= z(ip)
!
    if(xyz_inconsistent) then
       call add(errmsg,2,"incoming wavefield point coordinates of corner points of first cell do not "//&
            "match GLL points from which cell was constructed: inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file",myname)
       return
    end if
!
    allocate(wp_idx(this%ncell))
!
    do icell = 1,this%ncell
       allocate(idx(ngll_per_element))
       idx = (/ (ip,ip=(icell-1)*ngll_per_element+1,icell*ngll_per_element) /)
       call associateVectorPointer(wp_idx(icell),idx)
    end do ! icell
  end subroutine locateWpInsideSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief transform given coordinates of points contained in cell icell to standard cell and compute their jacobian
!! \param this specfem3d inversion grid
!! \param x vector of global x coordinate (contains x-values in standard cell on exit)
!! \param y vector of global y coordinate (contains y-values in standard cell on exit)
!! \param z vector of global z coordinate (contains z-values in standard cell on exit)
!! \param jacobian contains the actual integration weights!! (cannot communicate NGLLX,NGLLY,NGLLZ to module integrationWeights)
!! \param type_standard_cell defines the shape of the standard cell, select specific routine dependent on type (4=Tetrahedron,6=Hexahedron)
!! \param errmsg error message
!
  subroutine transformToStandardCellSpecfem3dInversionGrid(this,icell,x,y,z,jacobian,type_standard_cell,errmsg)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    integer :: type_standard_cell
    real, dimension(:), intent(inout) :: x,y,z,jacobian
    type (error_message) :: errmsg
    ! local
    character (len=45) :: myname = 'transformToStandardCellSpecfem3dInversionGrid'
    character(len=400) :: errstr
    integer :: nwp,ip,ishift,ngll_per_element,ix,iy,iz
    logical :: xyz_inconsistent
!
    call addTrace(errmsg,myname)
!
    if(.not.this%is_defined) then
       call add(errmsg,2,"inversion grid not yet defined",myname)
       return
    end if
!
    ! in routine transformVectorGlobalToLocalInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined, icell is valid and that x,y,z contain values and are all of same length!
    nwp = size(x)
!
    ngll_per_element = this%NGLLX*this%NGLLY*this%NGLLZ
    if(nwp/=ngll_per_element) then
       write(errstr,*) "number of incoming wavefield points ",nwp," of ",icell,"'th inversion grid cell "//&
            "does not match number of GLL points ",ngll_per_element," contained in a cell: "//&
            "inversion grid and wavefield points are inconsistent, must be constructed from the very same "//&
            "specfem3dForASKI main file"
       call add(errmsg,2,errstr,myname)
       return
    end if
!
    ! We could check the (first few?, e.g. first cell) coordinates, stored in this%vtk_point, if they match the values in x,y,z to be sure.
    ! Here we check the corners of the first cell. if wavefield points were read from the very same file, the floating point representations
    ! should be exactly the same as here (so check with "/=" makes sense and should work)
    xyz_inconsistent = .false.
    ip = 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,1,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,1,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,1,icell) /= z(ip)
    ip = this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,2,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,2,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,2,icell) /= z(ip)
    ip = this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,3,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,3,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,3,icell) /= z(ip)
    ip = (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,4,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,4,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,4,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,5,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,5,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,5,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,6,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,6,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,6,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + this%NGLLX*this%NGLLY
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,7,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,7,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,7,icell) /= z(ip)
    ip = (this%NGLLZ-1)*this%NGLLX*this%NGLLY + (this%NGLLY-1)*this%NGLLX + 1
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(1,8,icell) /= x(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(2,8,icell) /= y(ip)
    xyz_inconsistent = xyz_inconsistent .or. this%vtk_points(3,8,icell) /= z(ip)
!
    if(xyz_inconsistent) then
       call add(errmsg,2,"incoming wavefield point coordinates of corner points of first cell do not "//&
            "match GLL points from which cell was constructed: inversion grid and wavefield points are "//&
            "inconsistent, must be constructed from the very same specfem3dForASKI main file",myname)
       return
    end if
!
    ! IF TYPE_STANDARD_CELL == -1 :
    !   as the standard interfaces to module integrationWeights do not permitt to communicate
    !   NGLLX,NGLLY,NGLLZ (in that case, module integrationWeights could have implemented (hardcoded) the
    !   standard GLL weights and compute the weights on its own), we communicate the weights
    !   via the variable jacobian
    !   in this fashion, other methods as well may use their own integration weights
    !   (don't need a new integration weights type for every method that wants to do that)
    !   ALSO RETURN XI,ETA,ZETA IN THIS CASE!
    if(type_standard_cell == -1) then
!
       ! set start index for accessing this%jacobian to last point index of previous cell
       ishift = (icell-1)*ngll_per_element
       ip = 0
       do iz = 1,this%NGLLZ
          do iy = 1,this%NGLLY
             do ix = 1,this%NGLLX
                ip = ip + 1
                jacobian(ip) = this%wgllx(ix)*this%wglly(iy)*this%wgllz(iz)*this%jacobian(ishift+ip)
                x(ip) = this%xigll(ix)
                y(ip) = this%etagll(iy)
                z(ip) = this%zetagll(iz)
             end do
          end do
       end do
!
    ! IF TYPE_STANDARD_CELL /= -1 :
    !   return jacobian and standard-cell coordinates xi,eta,zeta as expected by 
    !   module integrationWeights in case of integration weights types other than 6
    !   this way, all other types of integration weights may be used in combination with a
    !   specfem3dInversionGrid (and necessarily specfem3dWavefieldPoints)
    else ! type_standard_cell == -1
!
       ! set start index for accessing this%jacobian to last point index of previous cell
       ishift = (icell-1)*ngll_per_element
       ip = 0
       do iz = 1,this%NGLLZ
          do iy = 1,this%NGLLY
             do ix = 1,this%NGLLX
                ip = ip + 1
                jacobian(ip) = this%jacobian(ishift+ip)
                x(ip) = this%xigll(ix)
                y(ip) = this%etagll(iy)
                z(ip) = this%zetagll(iz)
             end do
          end do
       end do
!
    end if ! type_standard_cell == -1
!
    type_standard_cell = 6
  end subroutine transformToStandardCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get volume of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which volume should be returned
!! \param volume volume of cell icell
!! \param errmsg error message
!
  subroutine getVolumeCellSpecfem3dInversionGrid(this,icell,volume,errmsg)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: volume
    type (error_message) :: errmsg
    ! local
    character (len=35) :: myname = 'getVolumeCellSpecfem3dInversionGrid'
    integer :: ix,iy,iz,ip
!
    call addTrace(errmsg,myname)
!
    ! in routine transformVectorGlobalToLocalInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
!
    volume = 0.
    ! set start index for accessing this%jacobian to last point index of previous cell
    ip = (icell-1)*this%NGLLX*this%NGLLY*this%NGLLZ
    do iz = 1,this%NGLLZ
       do iy = 1,this%NGLLY
          do ix = 1,this%NGLLX
             ip = ip + 1
             volume = volume + this%wgllx(ix)*this%wglly(iy)*this%wgllz(iz)*this%jacobian(ip)
          end do
       end do
    end do
  end subroutine getVolumeCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get center of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which center should be returned
!! \param xc first coordinate of center of cell icell
!! \param yc second coordinate of center of cell icell
!! \param zc third coordinate of center of cell icell
!! \param errmsg error message
!
  subroutine getCenterCellSpecfem3dInversionGrid(this,icell,xc,yc,zc,errmsg)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: xc,yc,zc
    type (error_message) :: errmsg
    ! local
    character (len=35) :: myname = 'getCenterCellSpecfem3dInversionGrid'
!
    call addTrace(errmsg,myname)
!
    ! in routine transformVectorGlobalToLocalInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
    xc = this%cell_center(1,icell)
    yc = this%cell_center(2,icell)
    zc = this%cell_center(3,icell)
  end subroutine getCenterCellSpecfem3dInversionGrid
!------------------------------------------------------------------------
!> \brief get radius of inversion grid cell
!! \param this inversion grid
!! \param icell index of inversion grid for which radius should be returned
!! \param radius radius of cell icell
!! \param errmsg error message
!
  subroutine getRadiusCellSpecfem3dInversionGrid(this,icell,radius,errmsg)
    type (specfem3d_inversion_grid) :: this
    integer, intent(in) :: icell
    real :: radius
    type (error_message) :: errmsg
    ! local
    character (len=35) :: myname = 'getRadiusCellSpecfem3dInversionGrid'
    real, dimension(3) :: p1,p2,p3,p4,p5,p6,p7,p8
!
    call addTrace(errmsg,myname)
!
    ! in routine transformVectorGlobalToLocalInversionGrid of module inversionGrid it was already assured
    ! that this%is_defined and icell is valid
!
    ! pi is the vector pointing from cell center to i'th cell corner
    p1 = this%vtk_points(:,1,icell) - this%cell_center(:,icell)
    p2 = this%vtk_points(:,2,icell) - this%cell_center(:,icell)
    p3 = this%vtk_points(:,3,icell) - this%cell_center(:,icell)
    p4 = this%vtk_points(:,4,icell) - this%cell_center(:,icell)
    p5 = this%vtk_points(:,5,icell) - this%cell_center(:,icell)
    p6 = this%vtk_points(:,6,icell) - this%cell_center(:,icell)
    p7 = this%vtk_points(:,7,icell) - this%cell_center(:,icell)
    p8 = this%vtk_points(:,8,icell) - this%cell_center(:,icell)
!
    ! return as radius the maximum distance of a corner point from the cell center
    radius = max( sqrt(sum(p1*p1)) , sqrt(sum(p2*p2)) , sqrt(sum(p3*p3)) , sqrt(sum(p4*p4)) , &
                  sqrt(sum(p5*p5)) , sqrt(sum(p6*p6)) , sqrt(sum(p7*p7)) , sqrt(sum(p8*p8)) )
  end subroutine getRadiusCellSpecfem3dInversionGrid
!
end module specfem3dInversionGrid
